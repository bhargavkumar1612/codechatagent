
### 1.  in app.py add changes to add a flask api with a get endpoint which returns hello world

### Changes_required
#### app.py
```python
from flask import Flask
app = Flask(__name__)
@app.route('/', methods=['GET'])
def hello():
    return 'Hello World'
if __name__ == '__main__':
    app.run(debug=True)
```

### Impact_analysis
The modification will lead to a new Flask API with a single GET endpoint returning 'Hello World'. This API can be called from any client (web, mobile) over HTTP making the functionality accessible over the network..

### Potential_risks
The Flask API must be properly secured to prevent malicious access. Also, as the Flask app runs in its own server, running the app locally might conflict with other apps running on the same port.

### Suggested_modifications
Ensure the Flask API is properly secured using correct HTTP security headers like X-Frame-Options, Strict-Transport-Security, Content-Security-Policy, X-Content-Type-Options, and X-XSS-Protection. Also, make sure the port Flask API runs on is configurable and does not conflict with other local apps.



### 2. now add a post api that take <some_name> as input and prints it in the console

### Changes_required
#### app.py
```python
from flask import Flask, request
app = Flask(__name__)
@app.route('/hello', methods=['GET'])
def hello():
    return 'Hello World'

@app.route('/print', methods=['POST'])
def print():
    some_name = request.json['some_name']
    print(some_name)
    return 'Printed {} in console.'.format(some_name)

if __name__ == '__main__':
    app.run(debug=True)
```

### Impact_analysis
This change introduces a new POST API endpoint, '/print'. This endpoint prints the input parameter 'some_name' in the console, allowing for name-based greetings or acknowledgements.

### Potential_risks
Since the input directly linked to console printing, potential injection attacks could occur and can lead to undesired consequences.

### Suggested_modifications
Validation for input 'some_name' should be added to ensure only acceptable names are processed. Consider using an allow list of printable characters and sanitize input to prevent code injection attacks.



### 3. add function in fibonacci.py to print nth finonacci number using recursive functions with momoisation 

### Changes_required
#### fibonacci.py
```python

def fibonacci(n, memo={}):
    if n in memo: return memo[n]
    if n <= 2: return 1
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]

if __name__ == '__main__':
    num = int(input('Enter a number: '))
    print('The {}th Fibonacci number is {}'.format(num, fibonacci(num)))
```

### Impact_analysis
The new function would calculate and print the nth Fibonacci number using recursion and memoization. This would result in significant performance improvements for large n, as Fibonacci numbers have an exponential time complexity due to overlapping subproblems in the naive recursive implementation.

### Potential_risks
The recursive solution is limited by Python's recursion depth limit. As such, it may not work correctly for very large input values of n.

### Suggested_modifications
An interative (bottom-up) technique can be used instead of recursion to generate Fibonacci numbers, bypassing the recursion depth limit. However, given memoization is specified, the provided solution is acceptable, keeping in mind the limitation.


